/*
    题目：《剑指Offer-面试题53-正则表达式匹配》
        请实现一个函数用来匹配包括'.'和'*'的正则表达式
        模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次(包含0次)
        在本题中，匹配是指字符串的所有字符匹配整个模式
        例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但是与"aa.a"和"ab*a"均不匹配      
    思路：
        难点在于'*'可以匹配包括0次在内的任意次数次'*'之前一个字符
        分为两种情况讨论：
        （1）模式串下一位为'*'
            又分为两种情况：
            ① 字符串当前位 与 模式串当前位 通过具体字符一一匹配 或 通过模式位'.' 匹配
                匹配后的移位又分为三种情况：
                a. 字符串后移一位，模式串不移位，即模式串用后面的'*'重复其当前位一次，之后还可能继续重复该位('*'仍有用)
                b. 字符串后移一位，模式串后移两位，即模式串后面的'*'重复其当前位一次，之后不再重复该位('*'已用完)
                c. 字符串不移位，模式串后移两位，即模式串后面的'*'一次也不重复当前位，直接跳过当前位和'*'，将匹配字符串当前位的任务交给'*'之后的模式字符
            ② 字符串当前位 与 模式串当前位 不匹配
                这时候的不匹配不能直接返回false，因为下一个模式位是'*'，可以让当前不匹配的模式位出现0次(即不出现)
                对应的移位情况为：字符串不移位，模式串后移两位，即跳过当前模式位和下一个位置的'*'('*'已用完)
        （2）模式串下一位非’*‘
            又分为两种情况：
            ① 字符串当前位 与 模式串当前位 通过具体字符一一匹配 或 通过模式位'.' 匹配
                匹配后的移位只有一种情况：字符串后移一位，模式串后移一位
            ② 字符串当前位 与 模式串当前位 不匹配
                这时候的不匹配就应该直接返回false，因为当前模式位后面没有'*'使当前不匹配的模式位出现0次了
*/

class Solution
{
  public:
    bool match(char *str, char *pattern)
    {
        if (str == nullptr || pattern == nullptr)
            return false;

        return matchCore(str, pattern);
    }

    bool matchCore(char *str, char *pattern)
    {
        // 递归的边界条件很关键！
        if (*str == '\0' && *pattern == '\0') // 字符串和模式同时结束，匹配成功
            return true;

        if (*str != '\0' && *pattern == '\0') // 字符串结束，但模式还未结束
            return false;

        if (*(pattern + 1) == '*') // 模式下一位为'*'
        {
            if (*pattern == *str || (*pattern == '.' && *str != '\0'))
                return matchCore(str + 1, pattern)        // 字符串匹配一位，模式不动，用‘*‘重复模式前一个字符
                       || matchCore(str + 1, pattern + 2) // 字符串匹配一位，模式后移两位，即用掉模式当前位，且之后不再重复该位，即不使用'*'做重复
                       || matchCore(str, pattern + 2);    // 字符串不匹配，让模式跳过两位，即让当前模式位重复0次(*的作用)
            else
                return matchCore(str, pattern + 2); // 字符串不匹配当前模式位，让模式跳过两位，即让当前模式位重复0次('*'的作用)
        }

        if (*str == *pattern || (*pattern == '.' && *str != '\0')) // 模式下一位非'*'，分为正常字符一一匹配和模式位通过'.'匹配当前字符串字符
            return matchCore(str + 1, pattern + 1);

        return false;
    }
};